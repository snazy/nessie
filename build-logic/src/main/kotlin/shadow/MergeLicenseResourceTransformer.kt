/*
 * Copyright (C) 2025 Dremio
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package shadow

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowCopyAction
import com.github.jengelman.gradle.plugins.shadow.transformers.CacheableTransformer
import com.github.jengelman.gradle.plugins.shadow.transformers.ResourceTransformer
import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import java.nio.charset.StandardCharsets.UTF_8
import java.util.LinkedHashSet
import javax.inject.Inject
import org.apache.tools.zip.ZipEntry
import org.apache.tools.zip.ZipOutputStream
import org.gradle.api.file.FileTreeElement
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input

/**
 * Generates a license file using the configured license text source.
 *
 * A mandatory `SPDX-License-Identifier` is placed in front of the license text to avoid ambiguous
 * license detection by license-detection-tools.
 *
 * License texts found in the files names `META-INF/LICENSE`, `META-INF/LICENSE.txt`,
 * `META-INF/LICENSE.md`, `LICENSE`, `LICENSE.txt`, `LICENSE.md` are included from the shadow jar
 * sources. Use the [PatternFilterable][org.gradle.api.tasks.util.PatternFilterable] functions to
 * specify a different set of files to include, the paths mentioned above are then not considered
 * unless explicitly included.
 */
@Suppress("unused")
@CacheableTransformer
open class MergeLicenseResourceTransformer @Inject constructor(objectFactory: ObjectFactory) :
  WithPatternFilterable(
    defaultIncludes =
      setOf(
        "META-INF/LICENSE",
        "META-INF/LICENSE.txt",
        "META-INF/LICENSE.md",
        "LICENSE",
        "LICENSE.txt",
        "LICENSE.md",
      )
  ),
  ResourceTransformer by ResourceTransformer.Companion {

  override fun canTransformResource(element: FileTreeElement): Boolean {
    return patternSpec.isSatisfiedBy(element)
  }

  /** Path to write the aggregated license file to. Defaults to `META-INF/LICENSE`. */
  @get:Input
  val outputPath: Property<String> =
    objectFactory.property(String::class.java).value("META-INF/LICENSE")

  /**
   * The generated license file is potentially a collection of multiple license texts. To avoid
   * ambiguous license detection by license-detection-tools, an SPDX license identifier header
   * (`SPDX-License-Identifier:`) is added at the beginning of the generated file if the value of
   * this property is present and not empty. Defaults to `Apache-2.0`.
   */
  @get:Input
  val artifactLicenseSpdxId: Property<String> =
    objectFactory.property(String::class.java).value("Apache-2.0")

  /** Path to the project's license text, this property *must* be configured. */
  @get:Input val artifactLicense: RegularFileProperty = objectFactory.fileProperty()

  /**
   * Separator between the project's license text and license texts from the included dependencies.
   */
  @get:Input
  val firstSeparator: Property<String> =
    objectFactory
      .property(String::class.java)
      .value(
        """
        
        ${"-".repeat(120)}
        
        This artifact includes dependencies with the following licenses:
        ----------------------------------------------------------------

        """
          .trimIndent()
      )

  /** Separator between included dependency license texts. */
  @get:Input
  val separator: Property<String> =
    objectFactory.property(String::class.java).value("\n\n${"-".repeat(120)}\n\n")

  private val elements: MutableSet<String> = LinkedHashSet()

  override fun transform(context: TransformerContext) {
    val bytes = context.inputStream.readAllBytes()
    val content = bytes.toString(UTF_8).trim('\n', '\r')
    if (!content.isEmpty()) {
      elements.add(content)
    }
  }

  override fun hasTransformedResource(): Boolean = true

  override fun modifyOutputStream(os: ZipOutputStream, preserveFileTimestamps: Boolean) {
    os.putNextEntry(
      ZipEntry(outputPath.get()).apply { time = ShadowCopyAction.CONSTANT_TIME_FOR_ZIP_ENTRIES }
    )

    if (artifactLicenseSpdxId.isPresent) {
      val spdxId = artifactLicenseSpdxId.get()
      if (spdxId.isBlank()) {
        os.write("SPDX-License-Identifier: $spdxId\n".toByteArray(UTF_8))
      }
    }
    os.write(artifactLicense.get().asFile.readBytes())

    if (!elements.isEmpty()) {
      os.write(firstSeparator.get().toByteArray(UTF_8))
      os.write("\n".toByteArray(UTF_8))

      var first = true
      val separator = (this.separator.get() + "\n").toByteArray(UTF_8)
      for (element in elements) {
        if (!first) {
          os.write(separator)
        }
        os.write(element.toByteArray(UTF_8))
        first = false
      }
    }
    os.closeEntry()
  }

  private companion object {
    private val LICENSE_PATHS = setOf<String>("LICENSE", "LICENSE.txt", "LICENSE.md")
  }
}
